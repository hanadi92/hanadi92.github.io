<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>Etch - FFI</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">Etch</a></h1>
                <nav><ul>
                    <li><a href="/category/tech.html">tech</a></li>
                </ul></nav>
        </header><!-- /#banner -->

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="/rust-in-php.html">Part 1: Rust in PHP</a></h1>
<footer class="post-info">
        <abbr class="published" title="2024-02-17T19:03:00+01:00">
                Published: Sat 17 February 2024
        </abbr>
		<br />
        <abbr class="modified" title="2024-02-17T19:03:00+01:00">
                Updated: Sat 17 February 2024
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/hanadi.html">Hanadi</a>
        </address>
<p>In <a href="/category/tech.html">tech</a>.</p>
<p>tags: <a href="/tag/rust.html">Rust</a> <a href="/tag/php.html">PHP</a> <a href="/tag/ffi.html">FFI</a> </p>
</footer><!-- /.post-info --><p>Hypothesis: In PHP projects, executing high load code using Rust instead of PHP produces a higher performance.</p>
<p>Use case: A simple idea, rather useless but just to prove a point, our project accepts a location (in Stockholm)
and a time (%H:%M:%S) in order to fetch all the trains that would depart from the location in the entered time up to 10 minute.</p>
<p>Strategy: Build two implementations of finding the trains that would depart from a given location after a given time within 10 minutes.
One using pure PHP, benchmark and profile it. One using Rust in PHP, benchmark and profile it.</p>
<div class="section" id="dataset">
<h2>Dataset</h2>
<p>The dataset consist of train timetable. It has 2566 records and was taken from [kaggle](<a class="reference external" href="https://www.kaggle.com/datasets/abdeaitali/commuter-train-timetable">https://www.kaggle.com/datasets/abdeaitali/commuter-train-timetable</a>).
It was chosen because of its acceptable size. We should be able to point the performance difference of using this dataset in PHP and Rust.</p>
<p>The dataset contains many information about each train, we only are concerned about the departure terminal and the departure time.</p>
</div>
<div class="section" id="rust">
<h2>Rust</h2>
<p>First we define what we would like to deserialize the records of the dataset into, we call it Train:</p>
<div class="highlight"><pre><span></span><span class="cp">#[derive(Debug, Deserialize, Serialize)]</span>
<span class="k">struct</span> <span class="nc">Train</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cp">#[serde(rename = </span><span class="s">&quot;DepTime&quot;</span><span class="cp">)]</span>
<span class="w">    </span><span class="n">dep_time</span>: <span class="nb">String</span><span class="p">,</span>
<span class="w">    </span><span class="cp">#[serde(rename = </span><span class="s">&quot;DepTerminal&quot;</span><span class="cp">)]</span>
<span class="w">    </span><span class="n">dep_terminal</span>: <span class="nb">String</span><span class="p">,</span>
<span class="w">    </span><span class="c1">// many other fields</span>
<span class="p">}</span>
</pre></div>
<p>Then we read the csv and deserialize the records into a vector of trains:</p>
<div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">trains</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Train</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ReaderBuilder</span>::<span class="n">new</span><span class="p">()</span>
<span class="w">    </span><span class="p">.</span><span class="n">delimiter</span><span class="p">(</span><span class="sc">b&#39;,&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">has_headers</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">flexible</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">from_path</span><span class="p">(</span><span class="s">&quot;mini_data.csv&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;Error reading CSV file&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">deserialize</span><span class="p">()</span>
<span class="w">    </span><span class="p">.</span><span class="n">filter_map</span><span class="p">(</span><span class="o">|</span><span class="n">result</span><span class="o">|</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span>
<span class="w">    </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span>
</pre></div>
<p>We could then define two functions for the Train implementation, one to check the departing soon condition and one to check the departing from condition:</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">is_departing_soon</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">current_time</span>: <span class="kp">&amp;</span><span class="nc">NaiveTime</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">train_departure_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NaiveTime</span>::<span class="n">from_str</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">dep_time</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">time_difference</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">train_departure_time</span><span class="p">.</span><span class="n">signed_duration_since</span><span class="p">(</span><span class="o">*</span><span class="n">current_time</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Check if the train departure time is greater than the current time</span>
<span class="w">    </span><span class="c1">// and the time difference is less than or equal to 10 minutes (600 seconds).</span>
<span class="w">    </span><span class="n">train_departure_time</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">current_time</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">time_difference</span><span class="p">.</span><span class="n">num_seconds</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">600</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="nf">is_departing_from</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">current_place</span>: <span class="kp">&amp;</span><span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">train_departure_place</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">dep_terminal</span><span class="p">;</span>
<span class="w">    </span><span class="n">train_departure_place</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">current_place</span>
<span class="p">}</span>
</pre></div>
<p>At that point we could simply filter the vector of trains with the conditions:</p>
<div class="highlight"><pre><span></span><span class="c1">// Filter departing trains based on time</span>
<span class="kd">let</span><span class="w"> </span><span class="n">departing_trains</span>: <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="n">Train</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">trains</span>
<span class="w">    </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span>
<span class="w">    </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|</span><span class="n">train</span><span class="o">|</span><span class="w"> </span><span class="n">train</span><span class="p">.</span><span class="n">is_departing_soon</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current_time</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">train</span><span class="p">.</span><span class="n">is_departing_from</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current_place_str</span><span class="p">))</span>
<span class="w">    </span><span class="p">.</span><span class="n">collect</span><span class="p">();</span>
</pre></div>
</div>
<div class="section" id="ffi-or-no-ffi">
<h2>FFI or no FFI</h2>
<p>After some research, I decided to measure this by myself. Some experiments said that using FFI produces less performance that no-ffi.
But we will try this together!</p>
</div>
<div class="section" id="ffi-rust-side">
<h2>FFI Rust Side</h2>
<p>In order to compile the rust code into <tt class="docutils literal">.dll</tt> or <tt class="docutils literal">.dylib</tt> or whatever depending on the compiling machine, let's wrap the code with a function
that accepts the current time and current location to be called from C.</p>
<div class="highlight"><pre><span></span><span class="cp">#[no_mangle]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">find_departing_trains</span><span class="p">(</span>
<span class="w">    </span><span class="n">current_time</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">libc</span>::<span class="n">c_char</span><span class="p">,</span>
<span class="w">    </span><span class="n">current_terminal</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">libc</span>::<span class="n">c_char</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span>-&gt; <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">libc</span>::<span class="n">c_char</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">current_time_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">CStr</span>::<span class="n">from_ptr</span><span class="p">(</span><span class="n">current_time</span><span class="p">).</span><span class="n">to_string_lossy</span><span class="p">().</span><span class="n">into_owned</span><span class="p">()</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">current_place_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">CStr</span>::<span class="n">from_ptr</span><span class="p">(</span><span class="n">current_terminal</span><span class="p">).</span><span class="n">to_string_lossy</span><span class="p">().</span><span class="n">into_owned</span><span class="p">()</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="c1">// Parse the current_time string into a NaiveTime</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">current_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NaiveTime</span>::<span class="n">from_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current_time_str</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// ... code from above</span>

<span class="w">    </span><span class="c1">// Convert departing_trains to a JSON string or any other suitable format</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">serde_json</span>::<span class="n">to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">departing_trains</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// Allocate a CString with the result string</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result_cstring</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="n">result</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// Transfer ownership to the caller and obtain a raw pointer</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result_cstring</span><span class="p">.</span><span class="n">into_raw</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// Convert the raw pointer to a mutable pointer</span>
<span class="w">    </span><span class="n">result_ptr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">libc</span>::<span class="n">c_char</span>
</pre></div>
<p>We also need to free the memory allocated by rust:</p>
<div class="highlight"><pre><span></span><span class="c1">// Add a function to free the memory allocated by Rust</span>
<span class="cp">#[no_mangle]</span>
<span class="k">pub</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="k">fn</span> <span class="nf">free_rust_string</span><span class="p">(</span><span class="n">ptr</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="n">libc</span>::<span class="n">c_char</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Convert the pointer back to a CString, and then drop it to free the memory</span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CString</span>::<span class="n">from_raw</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Now we are done with rust and can build a release. Run the following command:</p>
<div class="highlight"><pre><span></span>cargo<span class="w"> </span>build<span class="w"> </span>--release
</pre></div>
<p>This would build the library under <tt class="docutils literal">target/release/something.dylib</tt> or dll or something.</p>
<p>Bonus! Using rust bench we can see how much time it takes the find_departing_trains function to return. Running the following bench with <tt class="docutils literal">cargo bench</tt>
results with this <tt class="docutils literal">test <span class="pre">tests::bench_workload</span> ... bench:&nbsp;&nbsp; 1,914,349 ns/iter <span class="pre">(+/-</span> 113,685)</tt></p>
<div class="highlight"><pre><span></span><span class="cp">#[cfg(test)]</span>
<span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cp">#![feature(test)]</span>
<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">test</span><span class="p">;</span>

<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ffi</span>::<span class="p">{</span><span class="n">c_char</span><span class="p">,</span><span class="w"> </span><span class="n">CString</span><span class="p">};</span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">test</span>::<span class="n">Bencher</span><span class="p">;</span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">mytrain</span>::<span class="n">find_departing_trains</span><span class="p">;</span>

<span class="w">    </span><span class="cp">#[bench]</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">bench_workload</span><span class="p">(</span><span class="n">b</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Bencher</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">c_time_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="s">&quot;14:54:20&quot;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">c_time</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">c_char</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_time_str</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">c_char</span><span class="p">;</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">c_place_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CString</span>::<span class="n">new</span><span class="p">(</span><span class="s">&quot;Tokoyo&quot;</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">c_place</span>: <span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">c_char</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_place_str</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">c_char</span><span class="p">;</span>

<span class="w">        </span><span class="n">b</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">find_departing_trains</span><span class="p">(</span><span class="n">c_time</span><span class="p">,</span><span class="w"> </span><span class="n">c_place</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="ffi-php-side">
<h2>FFI PHP Side</h2>
<p>Ok. In PHP we have to make sure we have the FFI extension enabled.</p>
<div class="highlight"><pre><span></span><span class="cp">&lt;?php</span>
<span class="nb">extension_loaded</span><span class="p">(</span><span class="s1">&#39;ffi&#39;</span><span class="p">)</span> <span class="k">or</span> <span class="k">die</span><span class="p">(</span><span class="s1">&#39;FFI extension is not enabled.&#39;</span><span class="p">);</span>
</pre></div>
<p>Then we load the functions from the built rust lib with FFI and call the <tt class="docutils literal">find_departing_trains</tt> function:</p>
<div class="highlight"><pre><span></span><span class="x">// Load the Rust library</span>
<span class="x">$ffi = FFI::cdef(&quot;</span>
<span class="x">    char* find_departing_trains(char* current_time, char* current_terminal);</span>
<span class="x">    void free_rust_string(char* ptr);</span>
<span class="x">&quot;, __DIR__ . &quot;/target/release/libmytrain.dylib&quot;);</span>
<span class="x">$result = $ffi-&gt;find_departing_trains(&quot;14:54:20&quot;, &quot;Kungsängen&quot;);</span>

<span class="x">// Convert the result to a PHP string</span>
<span class="x">$resultStr = FFI::string($result);</span>
<span class="x">// Free the memory allocated by Rust</span>
<span class="x">$ffi-&gt;free_rust_string($result);</span>
<span class="x">// Deserialize the JSON string into a PHP array</span>
<span class="x">$departingTrains = json_decode($resultStr, true);</span>
<span class="x">print_r($departingTrains);</span>
</pre></div>
<p>Using something as simple as microtime for timing find_departing_trains results with 0.0029921531677246 seconds.</p>
</div>
<div class="section" id="php-ext-rs-instead-of-ffi">
<h2>php-ext-rs (instead of FFI)</h2>
<p>Instead of using FFI, we could also build a PHP extension in Rust. This will be continued in part 2!</p>
</div>
<div class="section" id="pure-php-impl">
<h2>Pure PHP Impl.</h2>
<p>Our second implementation in PHP, which we will compare our rust performance results with. This will be continued in part 2!</p>
<p>Part 2 will also include the results! Stay tuned.</p>
</div>
                </article>
            </aside><!-- /#featured -->
        <section id="extras" class="body">
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="https://github.com/hanadi92">@github</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>